<!DOCTYPE html>
<html>
  <HEAD>
    <title>Lawrence's Blog Entries</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="../stylesheets/default.css">
    <link rel="stylesheet" type="text/css" href="../stylesheets/blog-stylesheet.css">
  </HEAD>
    <div id="containter">
    <div id="header">Lawrence Yu</div>
    <div class="navbar">
      <ul>
        <li class="navitem"><a href="../index.html">Home</a></li>
        <li class="navitem"><a href="../projects/goldgrabber.html">Projects</a></li>
        <li class="navitem"><a href="#">About Me</a></li>
        <li class="navitem"><a href="mailto:lawrenceyu1@gmail.com">Contact Me</a></li>
      </ul>
    </div>
    <div id="bodycontainer">
    <div id="body1">
        <p><span id="currentlink"><a href="t8-tech.html">Sorting Out the Sorts!</a></span></p>
        <p><a href="c8-conflict.html">Past Conflicts</a></p>
        <p><a href="t6-oop-concepts.html">Ruby Variable Types and Their Scope!</a></p>
        <p><a href="c6-stereotype-threat.html">Stereotype Threats</a></p>
        <p><a href="c5-feedback.html">My Pairing Experience at DBC</a></p>
        <p><a href="t5-ruby-classes.html">Classes Are In Session!</p>
        <p><a href="c4-tech-issues.html">Maintenance Headache!</p>
        <p><a href="t4-enumerable-methods.html">Ruby Enumerable:group_by</a></p>
        <p><a href="c3_thinking-style.html">My Thinking Style: Understanding and Learning</p>
        <p><a href="t3-arrays-hashes.html">Arrays Versus Hashes</a></p>
        <p><a href="t2-css-design.html">Introduction to CSS: Margin, Padding, and Borders</a></p>
        <p><a href="t1-git-blog.html">Introduction to Version Control, Git, and GitHub</a></p>
        <p><a href="c1-chefs-kitchen.html">My DBC Expectation</a></p>
      </div>
      <div id="body2">
        <h1>Sorting Out the Sorts!</h1>
        <h2>Comparing and Contrasting Types of Sorting Methods</h2>
        <h4>03/06/15</h4>
        <section>
          <p class="bodytext">In this week’s technical blog, I’ll be going over some common sorting methods programmers have developed but first let me go over the idea of sorting algorithms.  Sorting algorithms, as the name implies, are used to sort elements in a list into a certain order. Typically, the sorting order is numerical and lexicographical (dictionary or alphabetical). Sort algorithms are classified by their computational complexity using big O(n) notation, where n represents the number of elements. This value correlates to the computation time. I won’t go into detail about big O notation, just note efficiency is inversely proportionate to the value inside the parenthesis. There is a great deal of research out there trying to find the fastest and most efficient sorting algorithm.</p>

          <p class="bodytext">The first sorting algorithm I’ll discuss is the bubble sort algorithm. Bubble sort is one of the most basic and simplest sorts. Bubble sort compares adjacent items and swaps their positions if they are not ordered correctly.  The algorithm will continue this process until no more swaps can be made. In terms of performance, on average it has an O(n2) complexity meaning its efficiency decreases exponentially as the list size increases. Therefore, while bubble sort is simple to implement, it should almost never be used to sort lists</p>

          <p class="bodytext">A much more efficient algorithm programmers use is the quick sort. Also sometimes referred as the partition-exchange sort, is a comparison sort where an element is picked as an pivot point. Two new arrays are created where one array stores values greater than the pivot element and the other for lower values (values equal to the pivot element can go to either array).  The index of the pivot point is recorded and then a new pivot point is chosen from each sub array. This process is repeated until it can no longer form sub arrays. Finally, the indices all of the pivots elements are used to generate the sorted list. Mathematical analysis of quicksort shows that quick sort, on average, has complexity of  O(nlog(n)). </p>

          <p class="bodytext">Another algorithm with similar efficiency that programmers often use is call the merge sort. In the merge sort method, the list is first broken down in n single elements sublists. Each element is compared, sorted, and merged with an adjacent list. This process is then repeated until only one list remains (which would be your sorted list). Like the quick sort algorithm, merge sort has a computation complexity of O(nlog(n)).</p>

          <p class="bodytext">Too reiterate why you want to use quick or merge sort over bubble sort, suppose we had a computer that took a millisecond to computed something. Using bubble sort to sort something with 1,000 items would take 1000 seconds to compute. Both the quick sort and merge would take on average merely 3 seconds to compute! Each of the methods listed above can be tweaked and optimized to run faster. There are also tons of different sorts other there as well but so far the fastest computing ones are limited to O(nlog(n)). Perhaps after reading this blog, you’ll go other there and try to develop a new algorithm that can sort a list even faster!</p>

        </section>
      </div>
    </div>
    <div class="footer">
      <p id="footernotes">Copyright &#169; Lawrence Yu 2015</p>
      <a href="https://github.com/lawyu89/"><img class="resize" src="https://assets-cdn.github.com/images/modules/logos_page/GitHub-Mark.png" alt=""/></a>
      <a href="https://twitter.com/lawyu89"><img class="resize" src="http://www1.montpellier.inra.fr/ica2013/images/twitter_logo.png" alt=""/></a>
      <a href="https://www.facebook.com/lawrence.yu.336"><img class="resize" src="https://www.newbrandanalytics.com/blog/wp-content/uploads/2013/12/Facebook-Icon-2-1021x1024.png" alt=""/></a>
    </div>
  </div>
</html>